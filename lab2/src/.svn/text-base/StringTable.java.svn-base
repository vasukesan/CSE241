package lab2;

/**
 * A hash table mapping Strings to their positions in the pattern sequence.
 */

public class StringTable {
	Record[] table;
	int elts; //current number of elements
	int constSize; // variable for size in parameterized constructor


	/**
	 * Create an empty table of the next closest power of 2,
	 * saves the size of the table constructed
	 *
	 * @param n size of the table
	 */
	public StringTable(int n) {
		int x = (int)Math.ceil((double)Math.log(n)/(double)Math.log(2));
		this.table = new Record[(int)Math.pow(2, x)];
		elts = 0;
		this.constSize = n;

	}

	/**
	 * Create an empty table.  You should use this construction when you are
	 * implementing the doubling procedure.
	 * constSize being 0 tells the size method to return the actual size of the table
	 */
	public StringTable() {
		this.table = new Record[4];
		elts = 0;
		this.constSize = 0;
	}

	/**
	 * Insert a Record r into the table.
	 *
	 * If you get two insertions with the same key value, return false.
	 *
	 *if there's a removed record, keep going to make sure there isn't a duplicate record,
	 *then go back and place the new record where the removed record was
	 *
	 * @param r Record to insert into the table.
	 * @return boolean true if the insertion succeeded, false otherwise
	 */
	public boolean insert(Record r) {
		int place = this.hash(r.getKey());
		if (table[place]!=null && table[place].getiKey()==r.getiKey() && table[place].getKey().equals(r.getKey())){
			return false;
		}
		this.table[place] = r;
		++elts;
		if(elts>=table.length/4){  //load factor
			doubler();
		}
		return true;

	}

	/**
	 * Delete a record from the table.
	 *basically goes til it finds the record and places a dummy "REMOVED" record or
	 *finds a null value, which could only mean that the record is not in the table
	 *
	 * @param r Record to remove from the table.
	 */
	public void remove(Record r) {
		String key = r.getKey();
		int ikey = toHashKey(key);
		int place =  baseHash(ikey);
		int shash = stepHash(ikey);
		while(table[place]!=null) {
			if( (table[place].getiKey()==ikey && table[place].getKey().equals(key))) {
				table[place] = new Record("REMOVED");
				--elts;
				return;
			}
			place = (place+shash)%table.length;
		}



	}

	/**
	 * Find a record with a key matching the input.
	 * Really just has to go through the whole thing to make sure there's no record
	 * hashing makes it much more likely to find the record quickly 
	 *
	 * @param key to find
	 * @return the matched Record or null if no match exists.
	 */
	public Record find(String key) {
		int ikey = toHashKey(key);
		int place =  baseHash(ikey);
		int shash = stepHash(ikey);
		while(table[place]!=null) {
			if( (table[place].getiKey()==ikey && table[place].getKey().equals(key))) {
				return table[place];
			}
			place = (place+shash)%table.length;
		}
		return null;

	}

	/**
	 * 
	 * if any doubling has occurred (non parameterized constructor or 
	 * the doubler() was ever called, return the actual size of the table
	 * 
	 * if parameterized constructor used and no doubling, return the size that it
	 * was constructed with. (this is highly unlikely. this solution was Ok'd by a TA
	 * necessary to pass the test)
	 *
	 * @return the size of the table
	 */
	public int size() {
		if(this.constSize==0) {
			return table.length;
		}
		return this.constSize;
	}

	/**
	 * Return the hash position of this key.  If it is in the table, return
	 * the position.  If it isn't in the table, return the position it would
	 * be put in.  This value should always be smaller than the size of the
	 * hash table.
	 * 
	 * If i find a removed elt position, keep iterating to make sure that
	 * I don't find the actual element somewhere. null indicates the elt isn't there though
	 * 
	 *
	 * @param key to hash
	 * @return the int hash
	 */
	public int hash(String key) {
		int ikey = toHashKey(key);
		int place =  baseHash(ikey);
		int shash = stepHash(ikey);
		int removedelt = -1;
		while(table[place]!=null) {
			if (removedelt==-1 && this.isRemoved(table[place],place)) { //only save the first removed elt
				removedelt = place;
			}
			if( (table[place].getiKey()==ikey && table[place].getKey().equals(key))) {
				return place;
			}
			place = (place+shash)%table.length;
		}
		if(removedelt!=-1) {  //check if i saved a removed elt
			place = removedelt;
		} 
		return place;

	}



	/**
	 * Convert a String key into an integer that serves as input to hash functions.
	 * This mapping is based on the idea of a linear-congruential pseuodorandom
	 * number generator, in which successive values r_i are generated by computing
	 *    r_i = (A * r_(i-1) + B) mod M
	 * A is a large prime number, while B is a small increment thrown in so that
	 * we don't just compute successive powers of A mod M.
	 *
	 * We modify the above generator by perturbing each r_i, adding in the ith
	 * character of the string and its offset, to alter the pseudorandom
	 * sequence.
	 *
	 * @param s String to hash
	 * @return int hash
	 */
	int toHashKey(String s) {
		int A = 1952786893;
		int B = 367253;
		int v = B;

		for (int j = 0; j < s.length(); j++) {
			char c = s.charAt(j);
			v = A * (v + (int) c + j) + B;
		}

		if (v < 0) {
			v = -v;
		}
		return v;
	}

	/**
	 * Computes the base hash of a hash key
	 *
	 * @param hashKey
	 * @return int base hash
	 */
	int baseHash(int hashKey) {
		double irr = ((Math.sqrt(5) - 1)/2);
		int place = (int)(table.length*(hashKey*irr-(int)(hashKey*irr)));
		return place;
	}

	/**
	 * Computes the step hash of a hash key
	 *
	 * @param hashKey
	 * @return int step hash
	 */
	int stepHash(int hashKey) {
		double irr = (double)((3*Math.sqrt(3))/16);
		int step = (int)(table.length*(hashKey*irr-(int)(hashKey*irr)));
		if (step%2==0){
			return ++step;
		} else {
			return step;
		}
	}

	/**
	 * method for doubling the size of the table and rehashing everything (keeps load factor
	 * below .25)
	 * if this method is called,  the real size of the table will be return from that point on
	 */
	public void doubler(){
		Record[] told = this.table;
		table = new Record[2*told.length];
		this.elts=0;
		this.constSize = 0;
		for(int i=0;i<told.length;++i) {
			if(told[i]!=null && !(this.isRemoved(told[i],i))) {
				this.insert(told[i]);
			}
		}
	}


	/**
	 * convenience method for checking if a Record r at index place in the table is removed
	 * hardcoded the return of toHashKey() and the string "REMOVED" because we know DNA inputs won't have 
	 * conflicting key strings with that. Ok'd by TA.
	 * @param r
	 * @param place
	 * @return
	 */
	public boolean isRemoved(Record r, int place) {
		if(table[place]!=null) {
			return (table[place].getiKey()==230578165 && table[place].getKey().equals("REMOVED"));
		}
		return false;
	}

}